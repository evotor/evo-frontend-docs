# Evo Frontend Codestyle: Typescript & Angular

## Предисловие

Кодстайл фронтенда Эвотора ориентируется в первую очередь на официальный
кодстайл [Angular](https://angular.io/guide/styleguide), поэтому настоятельно рекомендуем внимательно ознакомиться с
этим документом.

Также рекомендуется ознакомиться с кратким
списком [Do's and Don'ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html) от
Typescript.

Ниже описаны ключевые моменты и особенности, которые не покрыты (или упомянуты вскользь) в основном кодстайле Angular.

## Базовые определения

### Сущности

Под сущностью в данном руководстве подразумевается:

* любая конструкция языка Typescript (переменная, класс, интерфейс, тип, константа и т.д.);
* любая сущность Angular (компонент, директива, модуль, пайп и т.д.).

### Префиксы и суффиксы

* Префикс — символы в начале слова.
* Суффикс — символы в конце слова.

## Основные правила именования сущностей

### Соблюдаем регистр

| Регистр | Использование |
|---|---|
| `kebab-case` или `dashed-case` | названия файлов / селектор компонента |
| `PascalCase` или `UpperCamelCase` | классы / интерфейсы / типы / enum / декораторы / параметры типов |
| `lowerCamelCase` или просто `camelCase` | локальные переменные / параметры функций / функции / методы / свойства / селектор директивы |
| `UPPER_SNAKE_CASE` или `SCREAMING_SNAKE_CASE` | глобальные константы |
| `lower_snake_case` или просто `snake_case` | не используется в TypeScript |

### Аббревиатуры

Аббревиатуры в названиях сущностей НУЖНО рассматривать как целые слова (акронимы), поэтому не следует выделять их в
названиях сущностей заглавными буквами (кроме случаев, когда это требуется внешним API):

Поэтому корректно писать

* `getFeedHtml`, а не <del>`getFeedHTML`</del>
* `loadApiUrl`, а не <del>`loadAPIURL`</del>

### Ошибки в написании слов

* НЕОБХОДИМО избегать опечаток и ошибок в написании английских слов.
* В IDE ДОЛЖНА быть установлена проверка грамматики, чтобы избежать ошибок.
* Если сомневаетесь над корректностью написания, посмотрите в переводчике или замените на более простое подходящее по
  смыслу слово.

### Булевы переменные и методы

* СЛЕДУЕТ использовать префикс `is` или `has`.
* НЕЖЕЛАТЕЛЬНО использовать другие префиксы для булевых переменных и методов.

[Хорошая статья](https://dev.to/michi/tips-on-naming-boolean-variables-cleaner-code-35ig) на эту тему.

### Знак `$`

* НЕОБХОДИМО использовать суффикс `$` для названий свойств класса и переменных типа `Observable`.

### Префикс `_`

* СЛЕДУЕТ избегать использования префикса или суффикса `_`. В том числе, для обозначения приватных свойств класса.
* Единственный ДОПУСТИМЫЙ кейс использования префикса — инкапсуляция значения через публичный геттер / сеттер:

    ```typescript
    class AuthTokenStore {
      private _token: string;

      get token(): string {
        return this._token;
      }
    }
    ```

### Псевдонимы сущностей в классе

* При необходимости создания псевдонимов внутри класса для сущностей вне этого класса СЛЕДУЕТ наследовать **регистр** и
  **название** этой сущности

    ```typescript
    const LIMIT = 10;

    class NewsListModel {
        readonly LIMIT = LIMIT;
    }
    ```

### Названия интерфейсов

* НЕЖЕЛАТЕЛЬНО использовать в названии интерфейса:
    * венгерскую нотацию с префиксом `I`: <del>`INewsList`</del>
    * суффикс `Interface`: <del>`NewsListInterface`</del>

> **Замечание:** при создании интерфейса СЛЕДУЕТ подумать, для чего этот интерфейс вообще создаётся, и эту особенность нужно отразить в названии. При этом необходимо помнить про принцип разделения интерфейсов ([ISP](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0)) — он поможет избежать перегруженных интерфейсов, которые не несут ничего, кроме отчаяния.

### Интерфейсы и контракты API

Для работы с API СЛЕДУЕТ использовать суффиксы `Response` / `Request`:

* `NewsItemResponse` — для описания объекта ответа сервера
* `NewsItemRequest` — для описания объекта тела запроса на сервер

### Возвратный тип метода или функции

* Для всех методов и функций НЕОБХОДИМО указывать возвратный тип.
* Если метод или функция ничего не возвращают, НЕОБХОДИМО указать тип `void`:

    ```typescript
    class NewsCardComponent implements OnInit {
        // bad
        ngOnInit() {
        }

        // good
        ngOnInit(): void {
        }
    }
    ```

## Сущности, файлы и папки

### 1.1. Принцип единой ответственности ([SRP](https://en.wikipedia.org/wiki/Single-responsibility_principle))

* При создании файла ЖЕЛАТЕЛЬНО соблюдать принцип единой ответственности: одна экспортируемая сущность на один файл.
* Исключения МОГУТ составлять файлы с несколькими экспортируемыми константами, связанными одной предметной областью
  (модуль, фича). При этом такой файл ДОЛЖЕН иметь название соответствующей предметной области.

### 1.2. Контроль количества кода

* Для классов ЖЕЛАТЕЛЬНО соблюдать ограничение в 400 строк кода.
* Для функций и методов ЖЕЛАТЕЛЬНО соблюдать ограничение в 75 строк кода.

### 1.4. Шаблон названия файла

* В имени файла НЕОБХОДИМО использовать только `kebab-case`. Другой регистр НЕ ДОПУСКАЕТСЯ.
* Имя файла ДОЛЖНО задаваться по шаблону `<feature>.<type>.<extension>`.
* Суффикс `<type>` НЕОБХОДИМО использовать для следующих типов сущностей:
    * `.module`
    * `.component`
    * `.directive`
    * `.service`
    * `.pipe`
    * `.decorator`
    * `.interceptor`
    * `.validator`
    * `.guard`
    * `.model`
    * `.collection`
* Использование других суффиксов `<type>` НЕ ДОПУСКАЕТСЯ: если тип сущности не указан выше, то суффикс не применяется.

### 1.5. Шаблон названия папки

* В имени папки НЕОБХОДИМО использовать `kebab-case`.
* Наличие точек в названии папки НЕДОПУСТИМО.

### 1.6. Строгое соответствие содержимого файла и его названия

* Название файла ДОЛЖНО полностью соответствовать экспортируемой сущности (с точностью до регистра).
* Исключение МОГУТ составлять файлы с несколькими экспортируемыми константами.

### 1.7. Распределение файлов по папкам

* В каждом модуле НЕОБХОДИМО распределять файлы сущностей по папкам в соответствии с типами сущностей.
* Выделяются следующие названия папок:
    * `classes` — для абстрактных и других вспомогательных классов (кроме классов моделей)
    * `components` — компоненты
    * `directives` — директивы
    * `constants` — глобальные константы
    * `guards` — гарды роутера
    * `interceptors` — интерсепторы
    * `interfaces` — интерфейсы
    * `enums` — перечисления
    * `types` — типы
    * `pages` — ЖЕЛАТЕЛЬНО выделить отдельную папку для компонентов страниц
    * `pipes` — пайпы
    * `services` — сервисы
    * `models` — классы моделей и коллекций предметной области
    * `modules` — модули
    * `validators` — валидаторы форм
    * `utils` — утилиты (классы со статичными методами)

### 1.8. Соответствие содержимого файла и его названия

#### Пример плохого соответствия

```
filename: product-type.enum.ts
```

```typescript
export enum AppProductType {
}
```

Проблемы:

* В сущности есть префикс `App`, в названии файла это не отражено.
* В названии файла присутствует недопустимый суффикс `enum`

## 2. Классы, интерфейсы, типы

### 2.1. Модификаторы доступа

* `public` ДОПУСКАЕТСЯ использовать только для парамеров конструктора класса.
* `public` для свойств и методов класса избыточен — в Typescript всё публично по умолчанию.

### 2.2. Модификатор `readonly`

* НЕОБХОДИМО помечать `readonly` входящие и исходящие свойства компонентов (с `@Input` и `@Output` декораторами).
* НЕОБХОДИМО помечать `readonly` псевдонимы внешних сущностей:
    ```typescript
    const LIMIT = 10;

    class NewsListModel {
        readonly LIMIT = LIMIT;
    }
    ```

## 3. Сущности Angular

### 3.1. Компоненты страниц

Компоненты, реализующие шаблон-контейнер раздела приложения.

#### Ключевые особенности

* Компонент страницы ДОЛЖЕН быть связан с роутером.
* Компонент МОЖЕТ не иметь селектора — компоненты этого вида не используются как элементы в других компонентах (
  единственное, для чего может пригодиться селектор — это Angular Dev Tools).
* НЕЖЕЛАТЕЛЬНО иметь в компоненте-странице какую-либо бизнес-логику, за исключением предоставления зависимостей для
  дочерних компонентов, работы с навигацией и т.д.
* Важно помнить, что компонент страницы — это не более, чем контейнер для вложенных компонентов.

#### Оформление

* Компонент страницы ДОЛЖЕН иметь окончание `-page` в блоке названия файла `<feature>`.
* Компоненты страниц ЖЕЛАТЕЛЬНО выносить в отдельную папку `pages`.

Пример структуры:

```
- pages
  - home-page
    - home-page.component.ts
    - home-page.component.html
    - home-page.component.scss
```

## 4. Операторы и операции сравнения и присваивания

## 4.1. Вычисления по короткой схеме

* ДОПУСКАЕТСЯ использование следующих операторов присваивания по короткой
  схеме ([short-circuiting assignment](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#short-circuiting-assignment-operators)):
    * `a += b`
    * `a -= b`
    * `a *= b`
    * `a /= b`
    * `a **= b`
    * `a ??= b`
    * `a ||= b`

* НЕ ДОПУСКАЕТСЯ использование короткой схемы в выражениях вместо `if`:
    ```typescript
    const t = 1;

    // bad
    (t > 0) && foo(t);

    // good
    if (t > 0) {
      foo(t);
    }
    ```

### 4.2. `!!` (двойное отрицание)

* ДОПУСКАЕТСЯ приведение к булеву типу при помощи двойного отрицания:

    ```typescript
    function hasValue(value: string): boolean {
        return !!value;
    }
    ```

### 4.3. `||` (логическое ИЛИ)

* ДОПУСКАЕТСЯ использование логического ИЛИ в операциях присваивания:

    ```typescript
    const valueWithFallback = value || 'fallback';
    ```

### 4.3. `??` (нулевое слияние)

* ДОПУСКАЕТСЯ использование оператора нулевого слияния:

    ```typescript
    const valueWithFallback = value ?? 'fallback';
    ```

### 4.4. Побитовые операторы

* При использовании побитовых операторов РЕКОМЕНДУЕТСЯ оставлять комментарий с описанием / ссылкой на задачу.
* НЕ РЕКОМЕНДУЕТСЯ использовать побитовые операторы для приведения к целому числу:
    ```typescript
    // bad
    const bad1 = 11.1 | 0;
    const bad2 = "11.1" | 0;
    const bad3 = ~~"11.1";

    // good
    const good1 = parseInt(11.1, 10);
    ```

### 4.5. Унарный `+`

* НЕ ДОПУСКАЕТСЯ использовать унарный плюс для приведения строки к числу:
    ```typescript
    // bad
    const badNum = +str;

    // good
    const goodNum = Number(str);

    // good (if you know what you are doing)
    const goodNum2 = parseInt(str, 10);
    ```

### 4.6. Тернарный оператор `? :`

* ДОПУСКАЕТСЯ использование тернарного оператора.
* НЕЖЕЛАТЕЛЬНО использовать тернарный оператор исключительно для контролирования порядка выполнения операций (без
  возврата или присваивания):
    ```typescript

    class FormComponent {
      // bad
      setDisabledState(isDisabled: boolean): void {
          isDisabled ? this.formControl.disable() : this.formControl.enable();
      }

      // good
      setDisabledState(isDisabled: boolean): void {
          const action = isDisabled ? 'disable' : 'enable';
          this.formControl[action]();
      }

      // also good
      setDisabledState(isDisabled: boolean): void {
          this.formControl[isDisabled ? 'disable' : 'enable']();
      }
    }
    ```

* Если выражение с тернарным оператором не помещается в одну строку, НЕОБХОДИМО оформлять его следующим образом:
    ```typescript
    const result = value
        ? Math.PI > 4
        : 'nope';
    ```
